# 693. Binary Number with Alternating Bits

Given a positive integer, check whether it has alternating bits: 
namely, if two adjacent bits will always have different values.

**Constraints:**

- `1 <= n <= 2^31 - 1`

## 基礎思路

本題要判斷一個正整數的二進位表示是否為「交錯位元」，也就是任意相鄰兩個位元必須不同（`0/1/0/1/...` 或 `1/0/1/0/...`）。核心在於用位元運算把「相鄰不同」轉換成一個可快速檢查的整體性質。

在思考解法時，可掌握以下關鍵觀察：

* **交錯位元的相鄰關係可被一次性編碼**：若將原數與其右移一位的結果做 XOR，相鄰位元不同的位置會產生 `1`，相鄰位元相同的位置會產生 `0`。
* **交錯位元的 XOR 結果會變成連續的全 1 形態**：當每一組相鄰位元都不同時，XOR 後會得到形如 `111...111` 的連續全 1 掩碼。
* **連續全 1 掩碼可用經典位元技巧判定**：對於 `111...111` 這種數字，加一會變成 `1000...000`，兩者按位與必為 0；只要不是全 1，就會出現某些位置同時為 1，使按位與不為 0。

依據以上特性，可以採用以下策略：

* 先用「右移 + XOR」把交錯性壓縮成「是否為連續全 1」的問題。
* 再用「與自身加一的按位與是否為 0」快速判定是否為連續全 1。
* 全程只使用常數次位元運算即可完成檢查。

## 解題步驟

### Step 1：以右移 XOR 將交錯性轉換為連續全 1 掩碼

透過將整數右移一位後做 XOR，可以把相鄰位元是否不同轉換成一個新的位元序列；若原本是交錯位元，這個結果會呈現為連續的全 1。

```typescript
// 與右移一位做 XOR，將「交錯」壓縮成一個連續全 1 的掩碼。
const mixed = n ^ (n >>> 1);
```

### Step 2：用「全 1 掩碼」的位元性質完成最終判定

若結果是 `0b111...111`，加一會變成 `0b1000...000`，兩者按位與必為 0；反之只要不是全 1，就會存在至少一個位置兩者同時為 1，使結果不為 0。

```typescript
// 對於 x = 0b111...111，x + 1 = 0b1000...000，因此 x & (x + 1) == 0。
// 若 x 不是全 1，至少會有一個位置兩者同時為 1 -> 結果 != 0。
return (mixed & (mixed + 1)) === 0;
```

## 時間複雜度

- 僅進行固定次數的位元運算（右移、XOR、加法、AND、比較）。
- 不依賴輸入大小的迭代或額外掃描。
- 總時間複雜度為 $O(1)$。

> $O(1)$

## 空間複雜度

- 只使用固定數量的暫存值來保存中間結果。
- 不配置任何額外陣列或動態結構。
- 總空間複雜度為 $O(1)$。

> $O(1)$
