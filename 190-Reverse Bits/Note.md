# 190. Reverse Bits

Reverse bits of a given 32 bits signed integer.

**Constraints:**

- `0 <= n <= 2^31 - 2`
- `n` is even.

## 基礎思路

本題要求將一個 32 位元整數的二進位表示進行「位元反轉」，也就是把最低位與最高位對調，依序將整段 32 個位元完全翻轉後回傳結果。由於題目限定為 32 位元範圍，且輸出需要以無號 32 位元的語意呈現，因此核心在於：**以固定 32 次迭代，逐位取出原數的最低位，並依序拼接到新結果的尾端**。

在思考解法時，可掌握以下核心觀察：

* **位元反轉本質是固定長度的重新排列**：
  不論輸入大小如何，都必須處理完整 32 個位元，因此可以用固定次數的流程完成。

* **逐位擷取 + 逐位累積是最直接且安全的策略**：
  每次取出目前的最低位元，將結果左移一位騰出空間，再把該位元放入最低位，即可逐步建立反轉後的序列。

* **全程以無號位移可避免符號擴展干擾**：
  以無號形式處理能確保右移時高位補 0，並且最終結果以 32 位元無號輸出，符合題目語意。

依據以上特性，可以採用以下策略：

* **先將輸入視為無號 32 位元整數來處理**，確保位移行為一致。
* **固定迭代 32 次**：每次取出最低位元並拼接到結果。
* **最後以無號 32 位元形式回傳**，確保輸出落在正確範圍表示。

此策略可在固定成本下完成完整位元反轉，流程單純且穩定。

## 解題步驟

### Step 1：初始化無號輸入與反轉結果

先將輸入轉為無號 32 位元表示，確保後續右移補 0；同時準備一個累積容器，用來逐步建立反轉後的位元序列。

```typescript
let unsignedValue = n >>> 0;
let result = 0;
```

### Step 2：以固定 32 次迭代逐位建構反轉序列

透過固定 32 次迭代保證完整處理所有位元。每一輪都先讓結果左移一位騰出空間，接著把目前輸入的最低位元接到結果的最低位，最後再將輸入無號右移一位以準備下一輪擷取。

```typescript
// 緊密的固定次數迴圈，使用無號位移。
for (let remaining = 32; remaining > 0; remaining--) {
  result = (result << 1) | (unsignedValue & 1);
  unsignedValue >>>= 1;
}
```

### Step 3：將結果以無號 32 位元形式輸出

反轉完成後，將結果轉為無號 32 位元表示回傳，確保輸出符合 32 位元無號整數的語意。

```typescript
return result >>> 0;
```

## 時間複雜度

- 固定執行 32 次迭代以處理所有位元；
- 每次迭代僅包含常數次位元操作。
- 總時間複雜度為 $O(1)$。

> $O(1)$

## 空間複雜度

- 僅使用固定數量的整數變數作為累積與暫存；
- 不使用任何額外與輸入大小相關的資料結構。
- 總空間複雜度為 $O(1)$。

> $O(1)$
